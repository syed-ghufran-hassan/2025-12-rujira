{
  "contract_name": "rujira-bow",
  "contract_version": "1.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "metadata",
      "strategy"
    ],
    "properties": {
      "metadata": {
        "$ref": "#/definitions/TokenMetadata"
      },
      "strategy": {
        "$ref": "#/definitions/Strategies"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Strategies": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "xyk"
            ],
            "properties": {
              "xyk": {
                "$ref": "#/definitions/Xyk"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "TokenMetadata": {
        "description": "Metadata represents a struct that describes a basic token.\n\nIt follows the general structure of the x/bank Metadata, however `denom` is omitted, and injected with the correct string",
        "type": "object",
        "required": [
          "description",
          "display",
          "name",
          "symbol"
        ],
        "properties": {
          "description": {
            "type": "string"
          },
          "display": {
            "description": "display indicates the suggested denom that should be displayed in clients.",
            "type": "string"
          },
          "name": {
            "description": "name defines the name of the token (eg: ruji)",
            "type": "string"
          },
          "symbol": {
            "description": "symbol is the token symbol usually shown on exchanges (eg: RUJI). This can be the same as the display.",
            "type": "string"
          },
          "uri": {
            "description": "URI to a document (on or off-chain) that contains additional information. Optional.",
            "type": [
              "string",
              "null"
            ]
          },
          "uri_hash": {
            "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that the document didn't change. Optional.",
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Xyk": {
        "type": "object",
        "required": [
          "fee",
          "min_quote",
          "step",
          "x",
          "y"
        ],
        "properties": {
          "fee": {
            "$ref": "#/definitions/Decimal"
          },
          "min_quote": {
            "$ref": "#/definitions/Uint128"
          },
          "step": {
            "$ref": "#/definitions/Decimal"
          },
          "x": {
            "type": "string"
          },
          "y": {
            "type": "string"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Executes a market trade based on current order book.",
        "type": "object",
        "required": [
          "swap"
        ],
        "properties": {
          "swap": {
            "type": "object",
            "required": [
              "min_return"
            ],
            "properties": {
              "callback": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/CallbackData"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "min_return": {
                "$ref": "#/definitions/Coin"
              },
              "to": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "properties": {
              "callback": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/CallbackData"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "min_return": {
                "description": "The minimum amount of LP shares to be returned",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "properties": {
              "callback": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/CallbackData"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "CallbackData": {
        "$ref": "#/definitions/Binary"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "strategy"
        ],
        "properties": {
          "strategy": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "quote"
        ],
        "properties": {
          "quote": {
            "$ref": "#/definitions/QuoteRequest"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "QuoteRequest": {
        "type": "object",
        "required": [
          "ask_denom",
          "offer_denom"
        ],
        "properties": {
          "ask_denom": {
            "description": "The denom that the Caller is asking for",
            "type": "string"
          },
          "data": {
            "description": "Optional binary data that should be pass-through from QuoteResponse::data",
            "anyOf": [
              {
                "$ref": "#/definitions/Binary"
              },
              {
                "type": "null"
              }
            ]
          },
          "min_price": {
            "description": "The minimum price that BOW must respond with This is used eg in FIN to reay the previous price quoted for and in ORCA to set the min price of the next premium",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "offer_denom": {
            "description": "Denom that the Caller is offering ie the token that will be sent by FIN to BOW Eg. if a market order USDC buy of RUJI on FIN is being executed, FIN will require RUJI to execute the swap and so the offer_denom here will be USDC and the ask_denom RUJI",
            "type": "string"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "migrate": null,
  "sudo": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "SudoMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "set_strategy"
        ],
        "properties": {
          "set_strategy": {
            "$ref": "#/definitions/Strategies"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Strategies": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "xyk"
            ],
            "properties": {
              "xyk": {
                "$ref": "#/definitions/Xyk"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Xyk": {
        "type": "object",
        "required": [
          "fee",
          "min_quote",
          "step",
          "x",
          "y"
        ],
        "properties": {
          "fee": {
            "$ref": "#/definitions/Decimal"
          },
          "min_quote": {
            "$ref": "#/definitions/Uint128"
          },
          "step": {
            "$ref": "#/definitions/Decimal"
          },
          "x": {
            "type": "string"
          },
          "y": {
            "type": "string"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "responses": {
    "quote": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "QuoteResponse",
      "type": "object",
      "required": [
        "price",
        "size"
      ],
      "properties": {
        "data": {
          "description": "Optionally provide arbitrary binary data that is returned in subsequent QuoteQuery's Provided in order to allow the market maker to load from storage only once, instead of for each iteration of the query",
          "anyOf": [
            {
              "$ref": "#/definitions/Binary"
            },
            {
              "type": "null"
            }
          ]
        },
        "price": {
          "description": "The price of the offer Quoted in ask_denom, so eg for RUIJ @ $5, an offer of RUJI for ask of USDC, price = 5 an offer of USDC for ask of RUJI, price = 0.2",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "size": {
          "description": "The size of the ask_denom that the market maker is willing to accept at the QuoteResponse::price",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "strategy": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StrategyResponse",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "xyk"
          ],
          "properties": {
            "xyk": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/Xyk"
                },
                {
                  "$ref": "#/definitions/XykState"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint256": {
          "description": "An implementation of u256 that is using strings for JSON encoding/decoding, such that the full u256 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances out of primitive uint types or `new` to provide big endian bytes:\n\n``` # use cosmwasm_std::Uint256; let a = Uint256::from(258u128); let b = Uint256::new([ 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8, ]); assert_eq!(a, b); ```",
          "type": "string"
        },
        "Xyk": {
          "type": "object",
          "required": [
            "fee",
            "min_quote",
            "step",
            "x",
            "y"
          ],
          "properties": {
            "fee": {
              "$ref": "#/definitions/Decimal"
            },
            "min_quote": {
              "$ref": "#/definitions/Uint128"
            },
            "step": {
              "$ref": "#/definitions/Decimal"
            },
            "x": {
              "type": "string"
            },
            "y": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "XykState": {
          "type": "object",
          "required": [
            "k",
            "shares",
            "x",
            "y"
          ],
          "properties": {
            "k": {
              "$ref": "#/definitions/Uint256"
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            },
            "x": {
              "$ref": "#/definitions/Uint128"
            },
            "y": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
